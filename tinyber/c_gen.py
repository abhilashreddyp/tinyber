#!/usr/bin/env python
# -*- Mode: Python -*-

import os
import sys

from asn1ate import parser
from asn1ate.sema import *

from tinyber.writer import Writer
from tinyber.walker import Walker
from tinyber.c_nodes import *

class CBackend:

    def __init__ (self, walker, module_name, base_path):
        self.walker = walker
        self.module_name = module_name
        self.base_path = base_path

    def gen_decoder (self, type_name, type_decl, node):
        # generate a decoder for a type assignment.
        sig = 'int decode_%s (%s_t * dst, buf_t * src)' % (type_name, type_name)
        self.hout.writelines (sig + ';')
        self.cout.writelines (sig, '{')
        with self.cout.indent():
            self.cout.writelines (
                'asn1raw_t tlv;',
            )
            node.emit_decode (self.cout, 'dst', 'src')
            self.cout.writelines ('return 0;')
        self.cout.writelines ('}', '')
        
    def gen_encoder (self, type_name, type_decl, node):
        # generate an encoder for a type assignment
        sig = 'int encode_%s (buf_t * dst, const %s_t * src)' % (type_name, type_name)
        self.cout.writelines (sig, '{')
        self.hout.writelines (sig + ';')
        with self.cout.indent():
            node.emit_encode (self.cout, 'dst', 'src')
            self.cout.writelines ('return 0;')
        self.cout.writelines ('}', '')

    def gen_codec_funs (self, type_name, type_decl, node):
        self.gen_decoder (type_name, type_decl, node)
        self.gen_encoder (type_name, type_decl, node)

    def generate_code (self):
        self.hout = Writer (open (self.base_path + '.h', 'wb'))
        self.cout = Writer (open (self.base_path + '.c', 'wb'))
        self.hout.writelines (
            '',
            '// generated by %r' % sys.argv,
            '// *** do not edit ***',
            '',
            '#ifndef _%s_H_' % self.module_name.upper(),
            '#define _%s_H_' % self.module_name.upper(),
            '',
            '#include <stdint.h>',
            '#include <string.h>',
            '#include "tinyber.h"',
            '',
            '#define TYB_FAILIF(x) do { if (x) { return -1; } } while(0)',
            '#define TYB_CHECK(x) TYB_FAILIF(-1 == (x))',
            ''
        )
        self.cout.writelines (
            '',
            '// generated by %r' % sys.argv,
            '// *** do not edit ***',
            '',
            '#include "%s.h"' % (self.module_name,),
            '',
            # needed for the inline defs when compiled with inlining disabled.
            'extern void init_obuf (buf_t * self, uint8_t * buffer, unsigned int size);',
            'extern void init_ibuf (buf_t * self, uint8_t * buffer, unsigned int size);',
            '',
        )

        self.tag_assignments = self.walker.tag_assignments

        # generate typedefs and prototypes.
        out = self.hout
        for (type_name, node, type_decl) in self.walker.defined_types:
            if isinstance (node, c_choice):
                node.emit_enum (out)
            out.write ('typedef ')
            node.emit (out)
            out.writelines (
                ' %s_t;' % (type_name,),
                '#define %s_MAX_SIZE %d' % (type_name, node.max_size()),
                ''
            )

        for (type_name, node, type_decl) in self.walker.defined_types:
            self.gen_codec_funs (type_name, type_decl, node)

        self.hout.writelines (
            '',
            '#endif // _%s_H_' % self.module_name.upper()
        )
        self.hout.close()
        self.cout.close()

def main (args):

    with open (args.file) as f:
        asn1def = f.read()

    parse_tree = parser.parse_asn1(asn1def)
    modules = build_semantic_model(parse_tree)
    assert (len(modules) == 1)
    base, ext = os.path.splitext (args.file)
    parts = os.path.split (base)
    module_name = parts[-1]
    if args.outdir:
        path = os.path.join (args.outdir, module_name)
    else:
        path = base

    # pull in the C-specific node implementations
    from tinyber import c_nodes
    walker = Walker (modules[0], c_nodes)
    walker.walk()

    backend = CBackend (walker, module_name, path)
    backend.generate_code()

if __name__ == '__main__':
    import argparse
    p = argparse.ArgumentParser (description='tinyber C code generator.')
    p.add_argument ('-o', '--outdir', help="output directory (defaults to location of input file)", default='')
    p.add_argument ('file', help="asn.1 spec", metavar="FILE")
    args = p.parse_args()
    main (args)
