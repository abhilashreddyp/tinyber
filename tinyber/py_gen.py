#!/usr/bin/env python
# -*- Mode: Python -*-

import os
import sys

from asn1ate import parser
from asn1ate.sema import *

from tinyber.writer import Writer
from tinyber.walker import Walker
from tinyber.py_nodes import *

class PythonBackend:

    def __init__ (self, walker, module_name, base_path):
        self.walker = walker
        self.module_name = module_name
        self.base_path = base_path

    def gen_decoder (self, type_name, type_decl, node):
        # generate a decoder for a type assignment.
        self.out.writelines ('def decode (self, src):')
        with self.out.indent():
            node.emit_decode (self.out)
            if not isinstance (node, c_sequence):
                # non-SEQUENCE defined types, capture final value.
                self.out.writelines ('self.value = v')
        
    def gen_encoder (self, type_name, type_decl, node):
        # generate an encoder for a type assignment
        self.out.writelines ('def encode (self, dst):')
        with self.out.indent():
            self.out.writelines ('pass')
            node.emit_encode (self.out, 'None')

    def gen_codec_funs (self, type_name, type_decl, node):
        self.gen_decoder (type_name, type_decl, node)
        self.gen_encoder (type_name, type_decl, node)

    def generate_code (self):
        self.out = Writer (open (self.base_path + '_ber.py', 'wb'), indent_size=4)
        self.out.writelines (
            '# -*- Mode: Python -*-',
            '# generated by %r' % sys.argv,
            '# *** do not edit ***',
            '',
            'from tinyber.codec import *',
            '',
        )
        self.tag_assignments = self.walker.tag_assignments
        # generate typedefs and prototypes.
        for (type_name, node, type_decl) in self.walker.defined_types:
            if isinstance (node, c_sequence):
                parent_class = 'SEQUENCE'
            else:
                parent_class = 'object'                
            self.out.writelines ('', 'class %s (%s):' % (type_name, parent_class))
            with self.out.indent():
                self.out.writelines (
                    'max_size = %d' % (node.max_size())
                )
                node.emit (self.out)
                self.gen_codec_funs (type_name, type_decl, node)
        self.out.close()

def main (args):

    with open (args.file) as f:
        asn1def = f.read()

    parse_tree = parser.parse_asn1(asn1def)
    modules = build_semantic_model(parse_tree)
    assert (len(modules) == 1)
    base, ext = os.path.splitext (args.file)
    parts = os.path.split (base)
    module_name = parts[-1]
    if args.outdir:
        path = os.path.join (args.outdir, module_name)
    else:
        path = base

    # pull in the python-specific node implementations
    from tinyber import py_nodes
    walker = Walker (modules[0], py_nodes)
    walker.walk()

    backend = PythonBackend (walker, module_name, path)
    backend.generate_code()

if __name__ == '__main__':
    import argparse
    p = argparse.ArgumentParser (description='tinyber Python code generator.')
    p.add_argument ('-o', '--outdir', help="output directory (defaults to location of input file)", default='')
    p.add_argument ('file', help="asn.1 spec", metavar="FILE")
    args = p.parse_args()
    main (args)
